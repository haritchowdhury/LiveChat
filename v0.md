"use client";

import type React from "react";
import {
createContext,
useState,
useEffect,
useContext,
type Dispatch,
type SetStateAction,
} from "react";
import type { Session } from "@supabase/supabase-js";
import { supabase } from "@/lib/supabaseClient";

// Define types for your data
export interface User {
id: string;
email: string;
// Add other user properties as needed
}

export interface Message {
id: string;
conversation_id: string;
sender_id: string;
content: string;
created_at: string;
// Add other message properties as needed
}

export interface Conversation {
id: string;
created_at: string;
updated_at: string;
last_message_id: string | null;
participants: any[]; // Replace 'any' with a more specific type if possible
last_message: Message | null;
unread_count: number;
// Add other conversation properties as needed
}

// Define the context type
interface ChatContextType {
user: User | null | undefined;
session: Session | null;
conversations: Conversation[];
currentConversationId: string | null;
setCurrentConversationId: Dispatch<SetStateAction<string | null>>;
messages: Message[];
setMessages: Dispatch<SetStateAction<Message[]>>;
loadingConversations: boolean;
userConversationIds: string[];
fetchConversations: () => Promise<void>;
sendMessage: (text: string, conversationId: string) => Promise<void>;
currentConversation: Conversation | null;
loadingMessages: boolean;
createConversation: (userId: string) => Promise<string>;
}

// Create the context
const ChatContext = createContext<ChatContextType | undefined>(undefined);

// Create a provider component
export const ChatProvider: React.FC<{ children: React.ReactNode }> = ({
children,
}) => {
const [user, setUser] = useState<User | null | undefined>(undefined);
const [session, setSession] = useState<Session | null>(null);
const [conversations, setConversations] = useState<Conversation[]>([]);
const [currentConversationId, setCurrentConversationId] = useState<
string | null

> (null);
> const [messages, setMessages] = useState<Message[]>([]);
> const [loadingConversations, setLoadingConversations] = useState(true);
> const [userConversationIds, setUserConversationIds] = useState<string[]>([]);

// Add these state variables
const [currentConversation, setCurrentConversation] =
useState<Conversation | null>(null);
const [loadingMessages, setLoadingMessages] = useState(false);

// Function to fetch conversations - moved outside useEffect to be reusable
const fetchConversations = async () => {
if (!user) return;

    const { data: participations, error } = await supabase
      .from("participants")
      .select("conversation_id")
      .eq("user_id", user.id);

    if (error) {
      console.error("Error fetching conversations:", error);
      setLoadingConversations(false);
      return;
    }

    if (!participations || participations.length === 0) {
      setConversations([]);
      setUserConversationIds([]); // Update the state
      setLoadingConversations(false);
      return;
    }

    const conversationIds = participations.map((p) => p.conversation_id);
    setUserConversationIds(conversationIds); // Store the IDs for later use

    // Get detailed conversation info
    const { data: conversationsData, error: conversationsError } =
      await supabase
        .from("conversations")
        .select(
          `
        *,
        participants:participants(
          id,
          user_id,
          last_read_message_id,
          user:users(*)
        )
      `
        )
        .in("id", conversationIds)
        .order("updated_at", { ascending: false });

    if (conversationsError) {
      console.error("Error fetching conversation details:", conversationsError);
      setLoadingConversations(false);
      return;
    }

    // Get last messages for each conversation
    const conversationsWithLastMessage = await Promise.all(
      conversationsData.map(async (conversation) => {
        if (conversation.last_message_id) {
          const { data: lastMessage } = await supabase
            .from("messages")
            .select("*")
            .eq("id", conversation.last_message_id)
            .single();

          // Calculate unread count
          const currentUserParticipant = conversation.participants.find(
            (p: any) => p.user_id === user.id
          );

          let unreadCount = 0;
          if (
            currentUserParticipant &&
            currentUserParticipant.last_read_message_id
          ) {
            const { count, error } = await supabase
              .from("messages")
              .select("*", { count: "exact", head: true })
              .eq("conversation_id", conversation.id)
              .gt(
                "created_at",
                supabase
                  .from("messages")
                  .select("created_at")
                  .eq("id", currentUserParticipant.last_read_message_id)
                  .single()
              );

            if (!error && count !== null) {
              unreadCount = count;
            }
          }

          return {
            ...conversation,
            last_message: lastMessage || null,
            unread_count: unreadCount,
          };
        }
        return {
          ...conversation,
          last_message: null,
          unread_count: 0,
        };
      })
    );

    setConversations(conversationsWithLastMessage);
    setLoadingConversations(false);

};

// Add the sendMessage function
const sendMessage = async (text: string, conversationId: string) => {
if (!user) return;

    // Optimistically add the message to the UI first
    const optimisticMessage = {
      id: `temp-${Date.now()}`,
      conversation_id: conversationId,
      sender_id: user.id,
      content: text,
      created_at: new Date().toISOString(),
      // read_by: [], // Assuming this is not needed
      // is_pinned: false, // Assuming this is not needed
    } as Message; // Type assertion

    // Add to local state immediately for better UX
    setMessages((prevMessages) => [...prevMessages, optimisticMessage]);

    // Create the message in the database
    const { data: messageData, error: messageError } = await supabase
      .from("messages")
      .insert({
        conversation_id: conversationId,
        sender_id: user.id,
        content: text,
      })
      .select()
      .single();

    if (messageError) {
      console.error("Error sending message:", messageError);
      // Remove the optimistic message on error
      setMessages((prevMessages) =>
        prevMessages.filter((msg) => msg.id !== optimisticMessage.id)
      );
      return;
    }

    // Update the conversation's last message and timestamp
    const { error: conversationError } = await supabase
      .from("conversations")
      .update({
        last_message_id: messageData.id,
        updated_at: new Date().toISOString(),
      })
      .eq("id", conversationId);

    if (conversationError) {
      console.error("Error updating conversation:", conversationError);
    }

    // Replace optimistic message with real one in case subscription is slow
    setMessages((prevMessages) =>
      prevMessages.map((msg) =>
        msg.id === optimisticMessage.id ? messageData : msg
      )
    );

};

// Add the createConversation function
const createConversation = async (userId: string): Promise<string> => {
if (!user) throw new Error("You must be logged in");
if (userId === user.id)
throw new Error("Cannot create conversation with yourself");

    // Check if conversation already exists
    const { data: existingParticipations } = await supabase
      .from("participants")
      .select("conversation_id")
      .eq("user_id", user.id);

    if (existingParticipations && existingParticipations.length > 0) {
      const existingConversationIds = existingParticipations.map(
        (p) => p.conversation_id
      );

      const { data: otherParticipations } = await supabase
        .from("participants")
        .select("conversation_id, conversation:conversations(is_group)")
        .eq("user_id", userId)
        .in("conversation_id", existingConversationIds);

      const existingDirectConversation = otherParticipations?.find(
        (p) => !p.conversation.is_group
      );

      if (existingDirectConversation) {
        return existingDirectConversation.conversation_id;
      }
    }

    // Create a new conversation
    const { data: conversationData, error: conversationError } = await supabase
      .from("conversations")
      .insert({
        is_group: false,
        updated_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (conversationError || !conversationData) {
      throw new Error("Failed to create conversation");
    }

    const conversationId = conversationData.id;

    // Add both users as participants
    const participantsToInsert = [
      {
        user_id: user.id,
        conversation_id: conversationId,
        last_read_message_id: null,
      },
      {
        user_id: userId,
        conversation_id: conversationId,
        last_read_message_id: null,
      },
    ];

    const { error: participantsError } = await supabase
      .from("participants")
      .insert(participantsToInsert);

    if (participantsError) {
      throw new Error("Failed to add participants to conversation");
    }

    return conversationId;

};

useEffect(() => {
// Get the current session
supabase.auth.getSession().then(({ data: { session } }) => {
setSession(session);
});

    // Listen for changes on auth state (logged in, signed out, etc.)
    supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });

}, []);

useEffect(() => {
if (!session?.user) {
setUser(null);
return;
}

    setUser({
      id: session.user.id,
      email: session.user.email || "",
    });

}, [session]);

useEffect(() => {
if (!user) return;

    // Call the fetchConversations function
    fetchConversations();

    // Subscribe to conversation updates
    const conversationsSubscription = supabase
      .channel("public:conversations")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "conversations" },
        (payload) => {
          console.log("Conversation change received!", payload);
          fetchConversations();
        }
      )
      .subscribe();

    // Subscribe to participant updates
    const participantsSubscription = supabase
      .channel("public:participants")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "participants" },
        (payload) => {
          console.log("Participant change received!", payload);
          fetchConversations();
        }
      )
      .subscribe();

    // Subscribe to ALL new messages in conversations the user is part of
    const messagesSubscription = supabase
      .channel("public:messages")
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
          filter:
            userConversationIds.length > 0
              ? `conversation_id=in.(${userConversationIds.join(",")})`
              : undefined,
        },
        (payload) => {
          console.log("New message received in global subscription:", payload);
          const newMessage = payload.new as Message;

          // If this is for the current conversation, update messages
          if (newMessage.conversation_id === currentConversationId) {
            setMessages((prevMessages) => {
              // Only add if not already present (avoid duplicates)
              if (!prevMessages.some((msg) => msg.id === newMessage.id)) {
                return [...prevMessages, newMessage];
              }
              return prevMessages;
            });
          }

          // Always update conversations list to show latest message
          fetchConversations();
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(conversationsSubscription);
      supabase.removeChannel(participantsSubscription);
      supabase.removeChannel(messagesSubscription);
    };

}, [user, currentConversationId, userConversationIds]);

// Load messages when current conversation changes
useEffect(() => {
if (!currentConversationId) {
setMessages([]);
setCurrentConversation(null);
return;
}

    setLoadingMessages(true);

    // Find the conversation in our list
    const conversation =
      conversations.find((c) => c.id === currentConversationId) || null;
    setCurrentConversation(conversation);

    // Get messages for the current conversation
    const fetchMessages = async () => {
      const { data, error } = await supabase
        .from("messages")
        .select("*")
        .eq("conversation_id", currentConversationId)
        .order("created_at", { ascending: true });

      if (error) {
        console.error("Error fetching messages:", error);
      } else {
        setMessages(data || []);
      }

      setLoadingMessages(false);

      // Update last read message if user is a participant
      if (user && conversation) {
        const participant = conversation.participants?.find(
          (p) => p.user_id === user.id
        );
        if (participant && data && data.length > 0) {
          const lastMessageId = data[data.length - 1].id;
          await supabase
            .from("participants")
            .update({ last_read_message_id: lastMessageId })
            .eq("id", participant.id);
        }
      }
    };

    fetchMessages();

}, [currentConversationId, conversations, user]);

const value: ChatContextType = {
user,
session,
conversations,
currentConversationId,
setCurrentConversationId,
messages,
setMessages,
loadingConversations,
userConversationIds,
fetchConversations,
sendMessage,
currentConversation,
loadingMessages,
createConversation,
};

return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
};

// Create a custom hook to use the context
export const useChat = () => {
const context = useContext(ChatContext);
if (!context) {
throw new Error("useChat must be used within a ChatProvider");
}
return context;
};
